# Critical Patterns for Purpose Coach

This document captures important patterns that have caused significant debugging time. Read this before making changes.

## 1. Clerk ID vs Database ID Translation

### The Problem
This project uses Clerk for authentication, which has its own ID system that differs from our database IDs.

**Clerk IDs:** 
- Format: `org_31KdjD9RIauvRC0OQ29HiOiXQPC`, `user_2abc123...`
- Always prefixed (`org_`, `user_`, etc.)
- Come from Clerk's API/hooks

**Database IDs:**
- Format: `cmeuy0pu70005dq7pdfendzug`
- CUID format, no prefix
- Generated by Prisma

### Why This Matters
Foreign key constraints in PostgreSQL require the exact ID that exists in the referenced table. Using a Clerk ID where a database ID is expected will cause:
```
ERROR: insert or update on table "UserProfile" violates foreign key constraint "UserProfile_companyId_fkey"
```

### The Solution Pattern

#### For Companies/Organizations:
```typescript
// ❌ WRONG - Will cause foreign key error
const { organization } = useOrganization()
await saveProfile({ 
  companyId: organization.id  // This is "org_xxx" - WRONG!
})

// ✅ CORRECT - Translate first
// 1. Create an API endpoint to lookup
export async function GET() {
  const { orgId } = await auth()
  const company = await prisma.company.findUnique({
    where: { clerkOrgId: orgId }
  })
  return NextResponse.json({ company })
}

// 2. Use in frontend
const response = await fetch('/api/user/company')
const { company } = await response.json()
await saveProfile({ 
  companyId: company.id  // This is "cmeuy..." - CORRECT!
})
```

#### For Users:
```typescript
// The pattern is the same - always translate
const { userId } = await auth() // This is "user_xxx"
const profile = await prisma.userProfile.findUnique({
  where: { clerkUserId: userId }  // Note: clerkUserId field
})
// Use profile.id for foreign keys, not userId
```

### Database Schema Reference
```prisma
model Company {
  id          String @id @default(cuid())  // Database ID
  clerkOrgId  String @unique              // Clerk's org ID
  // ... other fields
}

model UserProfile {
  id           String @id @default(cuid())  // Database ID
  clerkUserId  String @unique               // Clerk's user ID
  companyId    String?                      // References Company.id, NOT clerkOrgId!
  company      Company? @relation(...)
  // ... other fields
}
```

### Quick Debug Checklist
When you see a foreign key error:
1. Console.log the ID you're trying to save
2. Does it have a prefix? → It's a Clerk ID, needs translation
3. No prefix, looks like `cmeuy...`? → It's a database ID, should work
4. Check the API endpoint - is it looking up by the correct field?

### Real Example From This Project
**Before Fix (Hours of Debugging):**
```javascript
// onboarding/page.tsx
if (organization?.id) {
  payload.companyId = organization.id  // Sending "org_xxx"
}
```

**After Fix (Works):**
```javascript
// onboarding/page.tsx
// First, fetch company on mount
useEffect(() => {
  const fetchCompanyId = async () => {
    const response = await fetch('/api/user/company')
    const { company } = await response.json()
    setCompanyDatabaseId(company.id)
  }
  fetchCompanyId()
}, [organization])

// Then use the database ID
if (companyDatabaseId) {
  payload.companyId = companyDatabaseId  // Sending "cmeuy..."
}
```

## 2. [Add more patterns as discovered]

---

## Why This Document Exists

These patterns represent hours of debugging that could have been avoided. Each pattern here caused significant confusion and wasted time. By documenting them, we can:

1. Recognize the pattern immediately next time
2. Apply the correct solution without trial and error
3. Save hours of debugging foreign key constraints and similar issues

**Remember:** If you spend more than 15 minutes debugging something that seems like it should work, it's probably one of these patterns.